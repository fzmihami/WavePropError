<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: code/src/FluxComputation.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('FluxComputation_8cpp.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">FluxComputation.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of flux computation classes for the Shallow Water Equations on both collocated and staggered grids.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;omp.h&gt;</code><br />
<code>#include &quot;<a class="el" href="FluxComputation_8h_source.html">FluxComputation.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GlobalVariables_8h_source.html">GlobalVariables.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab5374d849e36ba16e42428a4674e16f3" id="r_ab5374d849e36ba16e42428a4674e16f3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5374d849e36ba16e42428a4674e16f3">upwind</a> (float V, float Q1, float Q2)</td></tr>
<tr class="memdesc:ab5374d849e36ba16e42428a4674e16f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upwind function for 1D advection problems.  <br /></td></tr>
<tr class="separator:ab5374d849e36ba16e42428a4674e16f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e356ed6b569840b09933d9538d1634" id="r_a03e356ed6b569840b09933d9538d1634"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03e356ed6b569840b09933d9538d1634">upwind</a> (float V, float Q1, float Q2, float Q3, float Q4)</td></tr>
<tr class="memdesc:a03e356ed6b569840b09933d9538d1634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upwind function with slope limiting for 1D advection problems.  <br /></td></tr>
<tr class="separator:a03e356ed6b569840b09933d9538d1634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427a5bc052b35ab5a40fa74efa38688" id="r_a1427a5bc052b35ab5a40fa74efa38688"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1427a5bc052b35ab5a40fa74efa38688">min3</a> (float a, float b, float c)</td></tr>
<tr class="separator:a1427a5bc052b35ab5a40fa74efa38688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb524ba719998ee7ffe777b35beda4d" id="r_a9cb524ba719998ee7ffe777b35beda4d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb524ba719998ee7ffe777b35beda4d">max3</a> (float a, float b, float c)</td></tr>
<tr class="separator:a9cb524ba719998ee7ffe777b35beda4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14240127a8376ac6eff63eaca802f766" id="r_a14240127a8376ac6eff63eaca802f766"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14240127a8376ac6eff63eaca802f766">minmod</a> (float a, float b, float c)</td></tr>
<tr class="memdesc:a14240127a8376ac6eff63eaca802f766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the MinMod limiter function.  <br /></td></tr>
<tr class="separator:a14240127a8376ac6eff63eaca802f766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047d256037d27435f4f1218b38685b9b" id="r_a047d256037d27435f4f1218b38685b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a047d256037d27435f4f1218b38685b9b">Recontruction_Order1</a> (float *Hn, float *Hl, float *Hr, unsigned int N)</td></tr>
<tr class="memdesc:a047d256037d27435f4f1218b38685b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs first-order reconstruction of state variables at cell interfaces.  <br /></td></tr>
<tr class="separator:a047d256037d27435f4f1218b38685b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1b58ffc138adc95d6b8573e56daf77" id="r_a0b1b58ffc138adc95d6b8573e56daf77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b1b58ffc138adc95d6b8573e56daf77">Recontruction_Order2</a> (float *Hn, float *Hl, float *Hr, unsigned int N)</td></tr>
<tr class="memdesc:a0b1b58ffc138adc95d6b8573e56daf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs second-order MUSCL reconstruction of state variables at cell interfaces.  <br /></td></tr>
<tr class="separator:a0b1b58ffc138adc95d6b8573e56daf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885eac6dccfcc8b73fdb27b433efa00b" id="r_a885eac6dccfcc8b73fdb27b433efa00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a885eac6dccfcc8b73fdb27b433efa00b">Recontruction_Order3</a> (float *Hn, float *Hl, float *Hr, unsigned int N)</td></tr>
<tr class="memdesc:a885eac6dccfcc8b73fdb27b433efa00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs third-order TVD reconstruction of state variables at cell interfaces.  <br /></td></tr>
<tr class="separator:a885eac6dccfcc8b73fdb27b433efa00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ccf497bda712978ba2fac7e211d13" id="r_ae61ccf497bda712978ba2fac7e211d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61ccf497bda712978ba2fac7e211d13">Recontruction_Order5</a> (float *Hn, float *Hl, float *Hr, unsigned int N)</td></tr>
<tr class="memdesc:ae61ccf497bda712978ba2fac7e211d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs fifth-order TVD reconstruction of state variables at cell interfaces.  <br /></td></tr>
<tr class="separator:ae61ccf497bda712978ba2fac7e211d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1f7f95f720e6c73d063f64fe10f87e" id="r_ade1f7f95f720e6c73d063f64fe10f87e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade1f7f95f720e6c73d063f64fe10f87e">Flux_CentralUpwind</a> (float *Hl, float *Hr, float *Ql, float *Qr, float *FluxH, float *FluxQ, unsigned int N)</td></tr>
<tr class="memdesc:ade1f7f95f720e6c73d063f64fe10f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Central-upwind scheme for numerical flux computation.  <br /></td></tr>
<tr class="separator:ade1f7f95f720e6c73d063f64fe10f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4a609a92dc39c7441057fcf4a70e2f" id="r_a1c4a609a92dc39c7441057fcf4a70e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c4a609a92dc39c7441057fcf4a70e2f">Flux_HLL</a> (float *Hl, float *Hr, float *Ql, float *Qr, float *FluxH, float *FluxQ, unsigned int N)</td></tr>
<tr class="memdesc:a1c4a609a92dc39c7441057fcf4a70e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLL (Harten, Lax, and van Leer) scheme for numerical flux computation.  <br /></td></tr>
<tr class="separator:a1c4a609a92dc39c7441057fcf4a70e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eca82ea44bc6e1f759e96835038d81" id="r_a06eca82ea44bc6e1f759e96835038d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06eca82ea44bc6e1f759e96835038d81">Flux_HLLC</a> (float *Hl, float *Hr, float *Ql, float *Qr, float *FluxH, float *FluxQ, unsigned int N)</td></tr>
<tr class="memdesc:a06eca82ea44bc6e1f759e96835038d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLLC (Harten, Lax, van Leer, and Contact) scheme for numerical flux computation.  <br /></td></tr>
<tr class="separator:a06eca82ea44bc6e1f759e96835038d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of flux computation classes for the Shallow Water Equations on both collocated and staggered grids. </p>
<p>This file defines the <code>flux</code> and <code><a class="el" href="classflux__staggered.html" title="Computes the fluxes for the Shallow Water Equations in a staggered grid.">flux_staggered</a></code> classes used to compute fluxes in the Shallow Water Equations. The <code>flux</code> class supports collocated grids using the Finite Volume Godunov method, while the <code><a class="el" href="classflux__staggered.html" title="Computes the fluxes for the Shallow Water Equations in a staggered grid.">flux_staggered</a></code> class is designed for staggered grids, implementing a conservative staggered scheme based on Stelling and Duinmeijer (2003). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ade1f7f95f720e6c73d063f64fe10f87e" name="ade1f7f95f720e6c73d063f64fe10f87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1f7f95f720e6c73d063f64fe10f87e">&#9670;&#160;</a></span>Flux_CentralUpwind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Flux_CentralUpwind </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Ql</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Qr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>FluxH</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>FluxQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Central-upwind scheme for numerical flux computation. </p>
<p>This function computes the numerical fluxes for the variables <code>h</code> (height) and <code>Q</code> (momentum) using the central-upwind scheme, as described by Kurganov and Petrova (2007).</p>
<p>The fluxes are calculated for each cell interface based on the left and right states, <code>Hl</code>, <code>Hr</code>, <code>Ql</code>, and <code>Qr</code>, and the speed of sound, <code>aL</code> and <code>aR</code>. The fluxes are computed for both <code>h</code> and <code>Q</code> using a central-upwind formula with local speeds <code>aL</code> and <code>aR</code>, and the fluxes are stored in <code>FluxH</code> and <code>FluxQ</code> respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Hl</td><td>The array of left state values for the height (h). </td></tr>
    <tr><td class="paramname">Hr</td><td>The array of right state values for the height (h). </td></tr>
    <tr><td class="paramname">Ql</td><td>The array of left state values for the momentum (Q). </td></tr>
    <tr><td class="paramname">Qr</td><td>The array of right state values for the momentum (Q). </td></tr>
    <tr><td class="paramname">FluxH</td><td>The array where the numerical flux for height (h) will be stored. </td></tr>
    <tr><td class="paramname">FluxQ</td><td>The array where the numerical flux for momentum (Q) will be stored. </td></tr>
    <tr><td class="paramname">N</td><td>The number of cells.</td></tr>
  </table>
  </dd>
</dl>
<p>The central-upwind numerical flux for each cell interface is computed as:</p>
<p class="formulaDsp">
\[  F_{h}^{i+1/2} = \frac{a_R F_{hL} - a_L F_{hR}}{a_R - a_L} + \frac{a_R a_L
(H_r^{i} - H_l^{i})}{a_R - a_L}
\]
</p>
<p class="formulaDsp">
\[  F_{Q}^{i+1/2} = \frac{a_R F_{uL} - a_L F_{uR}}{a_R - a_L} + \frac{a_R a_L
(Q_r^{i} - Q_l^{i})}{a_R - a_L}
\]
</p>
<p>where:</p>
<p class="formulaDsp">
\[  a_R = \max\left(0, u_R + \sqrt{G H_R}, u_L + \sqrt{G H_L}\right)
\]
</p>
<p class="formulaDsp">
\[  a_L = \min\left(0, u_R - \sqrt{G H_R}, u_L - \sqrt{G H_L}\right)
\]
</p>
<p>Reference: Kurganov, A., &amp; Petrova, G. (2007). </p>

</div>
</div>
<a id="a1c4a609a92dc39c7441057fcf4a70e2f" name="a1c4a609a92dc39c7441057fcf4a70e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4a609a92dc39c7441057fcf4a70e2f">&#9670;&#160;</a></span>Flux_HLL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Flux_HLL </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Ql</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Qr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>FluxH</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>FluxQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HLL (Harten, Lax, and van Leer) scheme for numerical flux computation. </p>
<p>This function computes the numerical fluxes for the variables <code>h</code> (height) and <code>Q</code> (momentum) using the HLL scheme (Harten, Lax, and van Leer, 1983).</p>
<p>The function calculates the fluxes for each cell interface based on the left and right states and local wave speeds, with the fluxes stored in the arrays <code>FluxH</code> and <code>FluxQ</code>. The fluxes are computed using the HLL algorithm.</p>
<p>The fluxes for height (<code>h</code>) and momentum (<code>Q</code>) are calculated using the following expressions:</p>
<p class="formulaDsp">
\[\begin{aligned}
F_{h}^{i+1/2} =
\begin{cases}
F_{hL}, &amp; \text{if } s_L &gt; 0 \\
F_{hR}, &amp; \text{if } s_R &lt; 0 \\
\frac{s_R F_{hL} - s_L F_{hR} + (s_L s_R) (H_R - H_L)}{s_R - s_L}, &amp;
\text{otherwise} \end{cases} 
\end{aligned}
\]
</p>
<p class="formulaDsp">
\[F_{Q}^{i+1/2} =
\begin{cases}
F_{Q_L}, &amp; \text{if } s_L &gt; 0 \\
F_{Q_R}, &amp; \text{if } s_R &lt; 0 \\
\frac{s_R F_{Q_L} - s_L F_{Q_R} + (s_L s_R) (Q_R - Q_L)}{s_R - s_L}, &amp;
\text{otherwise} \end{cases} \]
</p>
<p>where:</p><ul>
<li>\( s_L \) is the left wave speed,</li>
<li>\( s_R \) is the right wave speed,</li>
<li>\( F_{hL}, F_{hR} \) are the fluxes for height,</li>
<li>\( F_{Q_L}, F_{Q_R} \) are the fluxes for momentum.</li>
</ul>
<p>The wave speeds \( s_L \) and \( s_R \) are computed based on the local states and the characteristic speed of the system. The value \( h0 \) is computed based on the formulation in Toro (2009).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Hl</td><td>The array of left state values for the height (h). </td></tr>
    <tr><td class="paramname">Hr</td><td>The array of right state values for the height (h). </td></tr>
    <tr><td class="paramname">Ql</td><td>The array of left state values for the momentum (Q). </td></tr>
    <tr><td class="paramname">Qr</td><td>The array of right state values for the momentum (Q). </td></tr>
    <tr><td class="paramname">FluxH</td><td>The array where the numerical flux for height (h) will be stored. </td></tr>
    <tr><td class="paramname">FluxQ</td><td>The array where the numerical flux for momentum (Q) will be stored. </td></tr>
    <tr><td class="paramname">N</td><td>The number of cells.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference: Harten, A., Lax, P. D., &amp; van Leer, B. (1983). </p>

</div>
</div>
<a id="a06eca82ea44bc6e1f759e96835038d81" name="a06eca82ea44bc6e1f759e96835038d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06eca82ea44bc6e1f759e96835038d81">&#9670;&#160;</a></span>Flux_HLLC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Flux_HLLC </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Ql</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Qr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>FluxH</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>FluxQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HLLC (Harten, Lax, van Leer, and Contact) scheme for numerical flux computation. </p>
<p>This function computes the numerical fluxes for the variables <code>h</code> (height) and <code>Q</code> (momentum) using the HLLC scheme (Harten, Lax, van Leer, and Contact, 1983). The HLLC scheme is a modification of the HLL scheme, which incorporates a contact wave and resolves the Riemann problem by considering three waves: a left and right moving wave, and a contact wave.</p>
<p>The function computes the fluxes for each cell interface based on the left and right states (<code>Hl</code>, <code>Hr</code>, <code>Ql</code>, <code>Qr</code>) and the corresponding wave speeds.</p>
<p>The fluxes for height (<code>h</code>) and momentum (<code>Q</code>) are calculated using the following expressions:</p>
<p class="formulaDsp">
\[\begin{aligned}
F_{h}^{i+1/2} =
\begin{cases}
F_{hL}, &amp; \text{if } s_L &gt; 0 \\
F_{hR}, &amp; \text{if } s_R &lt; 0 \\
F_{hL} + s_L (h^*L - h_L), &amp; \text{if } 0 \leq s_0 \\
F_{hR} + s_R (h^*R - h_R), &amp; \text{if } s_0 &lt; 0
\end{cases}
\end{aligned}
\]
</p>
<p class="formulaDsp">
\[F_{Q}^{i+1/2} =
\begin{cases}
F_{Q_L}, &amp; \text{if } s_L &gt; 0 \\
F_{Q_R}, &amp; \text{if } s_R &lt; 0 \\
F_{Q_L} + s_L (q^*L - h_L u_L), &amp; \text{if } 0 \leq s_0 \\
F_{Q_R} + s_R (q^*R - h_R u_R), &amp; \text{if } s_0 &lt; 0
\end{cases}
\]
</p>
<p>where:</p><ul>
<li>\( s_L \) is the left wave speed,</li>
<li>\( s_R \) is the right wave speed,</li>
<li>\( s_0 \) is the middle wave speed (contact wave),</li>
<li>\( F_{hL}, F_{hR} \) are the fluxes for height,</li>
<li>\( F_{Q_L}, F_{Q_R} \) are the fluxes for momentum,</li>
<li>\( h^*L, h^*R \) are the star variables for height at the left and right states,</li>
<li>\( q^*L, q^*R \) are the star variables for momentum at the left and right states.</li>
</ul>
<p>The function uses intermediate variables, including \( h_0 \) (the averaged height), \( u_0 \) (the averaged velocity), and calculates the middle wave speed \( s_0 \) based on the expressions presented in Toro (2001).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Hl</td><td>The array of left state values for the height (h). </td></tr>
    <tr><td class="paramname">Hr</td><td>The array of right state values for the height (h). </td></tr>
    <tr><td class="paramname">Ql</td><td>The array of left state values for the momentum (Q). </td></tr>
    <tr><td class="paramname">Qr</td><td>The array of right state values for the momentum (Q). </td></tr>
    <tr><td class="paramname">FluxH</td><td>The array where the numerical flux for height (h) will be stored. </td></tr>
    <tr><td class="paramname">FluxQ</td><td>The array where the numerical flux for momentum (Q) will be stored. </td></tr>
    <tr><td class="paramname">N</td><td>The number of cells.</td></tr>
  </table>
  </dd>
</dl>
<p>Reference: Toro, 2001. "Shock-capturing methods for free-surface shallow flows." </p>

</div>
</div>
<a id="a9cb524ba719998ee7ffe777b35beda4d" name="a9cb524ba719998ee7ffe777b35beda4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb524ba719998ee7ffe777b35beda4d">&#9670;&#160;</a></span>max3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float max3 </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1427a5bc052b35ab5a40fa74efa38688" name="a1427a5bc052b35ab5a40fa74efa38688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1427a5bc052b35ab5a40fa74efa38688">&#9670;&#160;</a></span>min3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float min3 </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14240127a8376ac6eff63eaca802f766" name="a14240127a8376ac6eff63eaca802f766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14240127a8376ac6eff63eaca802f766">&#9670;&#160;</a></span>minmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float minmod </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the MinMod limiter function. </p>
<p>The MinMod function is a slope limiter used in high-resolution schemes to prevent spurious oscillations. It selects the smallest absolute value among the inputs if they have the same sign; otherwise, it returns zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First input value. </td></tr>
    <tr><td class="paramname">b</td><td>Second input value. </td></tr>
    <tr><td class="paramname">c</td><td>Third input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MinMod limited value.</dd></dl>
<p>The function follows these rules:</p><ul>
<li>If all three inputs are positive, it returns the minimum of the three.</li>
<li>If all three inputs are negative, it returns the maximum (most negative) of the three.</li>
<li>Otherwise, it returns zero to avoid introducing new extrema.</li>
</ul>
<p>Reference: Kim and Kim (2005) </p>

</div>
</div>
<a id="a047d256037d27435f4f1218b38685b9b" name="a047d256037d27435f4f1218b38685b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047d256037d27435f4f1218b38685b9b">&#9670;&#160;</a></span>Recontruction_Order1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Recontruction_Order1 </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs first-order reconstruction of state variables at cell interfaces. </p>
<p>This function approximates the state variables at the interface between computational cells using a first-order upwind reconstruction. It assigns values from the left and right neighboring cells, which can be used as inputs for a local Riemann solver in numerical flux computations.</p>
<p>The reconstruction follows:   </p><p class="formulaDsp">
\[U_L^{i+1/2} = U_i
\]
</p>
   <p class="formulaDsp">
\[U_R^{i+1/2} = U_{i+1}
\]
</p>
<p> where \( U_L \) and \( U_R \) are the left and right states at the interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Hn</td><td>Pointer to the array of state variables at cell centers (size N). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hl</td><td>Pointer to the array storing left interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hr</td><td>Pointer to the array storing right interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of grid points in the input array Hn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure that <code>Hl</code> and <code>Hr</code> arrays have been allocated with at least <code>N-1</code> elements. </dd></dl>

</div>
</div>
<a id="a0b1b58ffc138adc95d6b8573e56daf77" name="a0b1b58ffc138adc95d6b8573e56daf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1b58ffc138adc95d6b8573e56daf77">&#9670;&#160;</a></span>Recontruction_Order2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Recontruction_Order2 </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs second-order MUSCL reconstruction of state variables at cell interfaces. </p>
<p>This function computes the left and right interface states using the Monotonic Upstream-Centered Scheme for Conservation Laws (MUSCL), which provides a second-order accurate reconstruction with a Total Variation Diminishing (TVD) slope limiter.</p>
<p>The reconstructed interface values are given by:   </p><p class="formulaDsp">
\[U_L^{i+1/2} = U_i + \phi (r_L) (U_i - U_{i-1})
\]
</p>
   <p class="formulaDsp">
\[U_R^{i+1/2} = U_{i+1} - \phi (r_R) (U_{i+2} - U_{i+1})
\]
</p>
<p>where the slope ratio is defined as:    </p><p class="formulaDsp">
\[r_L = \frac{U_{i+1} - U_i}{U_i - U_{i-1}}, \quad
r_R = \frac{U_{i+1} - U_i}{U_{i+2} - U_{i+1}}
\]
</p>
<p>The function uses a Total Variation Diminishing (TVD) slope limiter to prevent oscillations. We use the Van-Leer MinMod limiter, defined as:   </p><p class="formulaDsp">
\[\phi (r, \theta) = \max \left(0, \min \left( \theta r, \frac{1 + r}{2},
\theta \right) \right) \]
</p>
<p>the value of \(\theta\) is defined as a constant in <a class="el" href="GlobalVariables_8cpp.html" title="This file contains the global constants and variables used in the numerical solver for wave propagati...">GlobalVariables.cpp</a> file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Hn</td><td>Pointer to the array of state variables at cell centers (size N). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hl</td><td>Pointer to the array storing left interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hr</td><td>Pointer to the array storing right interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of grid points in the input array Hn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure <code>Hl</code> and <code>Hr</code> arrays have at least <code>N-1</code> elements to avoid out-of-bounds errors. </dd></dl>

</div>
</div>
<a id="a885eac6dccfcc8b73fdb27b433efa00b" name="a885eac6dccfcc8b73fdb27b433efa00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885eac6dccfcc8b73fdb27b433efa00b">&#9670;&#160;</a></span>Recontruction_Order3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Recontruction_Order3 </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs third-order TVD reconstruction of state variables at cell interfaces. </p>
<p>This function implements the third-order Total Variation Diminishing (TVD) interpolation proposed by Kim and Kim (2005) for numerical flux computation. It ensures stability and prevents spurious oscillations using a nonlinear slope limiter.</p>
<p>The reconstructed interface values are given by:   </p><p class="formulaDsp">
\[U_L^{i+1/2} = U_i + \max \left(0, \min \left(2, 2r_{L,i}, \beta_L \right)
\right) (U_i - U_{i-1}) \]
</p>
  <p class="formulaDsp">
\[ U_R^{i+1/2} = U_{i+1} - \max \left(0, \min
\left(2, 2r_{R,i+1}, \beta_R \right) \right) (U_{i+2} - U_{i+1}) \]
</p>
<p>where:    </p><p class="formulaDsp">
\[\beta_L = \frac{1 + 2r_{L,i}}{3}, \quad
\beta_R = \frac{1 + 2r_{R,i+1}}{3}
\]
</p>
<p>and the slope ratios are:    </p><p class="formulaDsp">
\[r_{L,i} = \frac{U_{i+1} - U_i}{U_i - U_{i-1}}, \quad
r_{R,i+1} = \frac{U_{i+1} - U_i}{U_{i+2} - U_{i+1}}
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Hn</td><td>Pointer to the array of state variables at cell centers (size N). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hl</td><td>Pointer to the array storing left interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hr</td><td>Pointer to the array storing right interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of grid points in the input array Hn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes proper boundary handling for the first and last two grid points.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure <code>Hl</code> and <code>Hr</code> arrays have at least <code>N-1</code> elements to avoid out-of-bounds errors. </dd></dl>

</div>
</div>
<a id="ae61ccf497bda712978ba2fac7e211d13" name="ae61ccf497bda712978ba2fac7e211d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61ccf497bda712978ba2fac7e211d13">&#9670;&#160;</a></span>Recontruction_Order5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Recontruction_Order5 </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Hr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs fifth-order TVD reconstruction of state variables at cell interfaces. </p>
<p>This function implements a fifth-order Total Variation Diminishing (TVD) interpolation for numerical flux computation. It uses a nonlinear slope limiter to prevent spurious oscillations while maintaining high accuracy.</p>
<p>The reconstructed interface values are given by:   </p><p class="formulaDsp">
\[U_L^{i+1/2} = U_i + \frac{1}{2} \max \left(0, \min \left(2, 2r_{L,i}, \beta_L
\right) \right) (U_i - U_{i-1}) \]
</p>
   <p class="formulaDsp">
\[ U_R^{i+1/2} = U_{i+1} - \frac{1}{2}
\max \left(0, \min \left(2, 2r_{R,i+1}, \beta_R \right) \right) (U_{i+2} -
U_{i+1}) \]
</p>
<p>where the slope limiter coefficients are:    </p><p class="formulaDsp">
\[\beta_L = \frac{-2/r_{L,i-1} + 11 + 24r_{L,i} - 3r_{L,i}r_{L,i+1}}{30},
\quad \beta_R = \frac{-2/r_{R,i+2} + 11 + 24r_{R,i+1} -
3r_{R,i}r_{R,i+1}}{30} \]
</p>
<p>The slope ratios are computed as:    </p><p class="formulaDsp">
\[r_{L,i} = \frac{U_{i+1} - U_i}{U_i - U_{i-1}},
\quad r_{R,i+1} = \frac{U_{i} - U_{i-1}}{U_{i+1} - U_i}
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Hn</td><td>Pointer to the array of state variables at cell centers (size N). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hl</td><td>Pointer to the array storing left interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hr</td><td>Pointer to the array storing right interface values (size N-1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of grid points in the input array Hn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes proper boundary handling for the first and last two grid points.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure <code>Hl</code> and <code>Hr</code> arrays have at least <code>N-1</code> elements to avoid out-of-bounds errors.</dd></dl>
<p>Refrence: Kim and Kim (2005) </p>

</div>
</div>
<a id="ab5374d849e36ba16e42428a4674e16f3" name="ab5374d849e36ba16e42428a4674e16f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5374d849e36ba16e42428a4674e16f3">&#9670;&#160;</a></span>upwind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float upwind </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Q2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upwind function for 1D advection problems. </p>
<p>This function implements the basic upwind scheme. It returns one of the two input values, depending on the sign of the velocity.</p><ul>
<li>If the velocity (V) is positive, the function returns Q1.</li>
<li>If the velocity (V) is negative, the function returns Q2.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>The velocity. </td></tr>
    <tr><td class="paramname">Q1</td><td>The value at the left of the interface. </td></tr>
    <tr><td class="paramname">Q2</td><td>The value at the right of the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value corresponding to the upwind direction based on the velocity. </dd></dl>

</div>
</div>
<a id="a03e356ed6b569840b09933d9538d1634" name="a03e356ed6b569840b09933d9538d1634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e356ed6b569840b09933d9538d1634">&#9670;&#160;</a></span>upwind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float upwind </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Q3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Q4</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upwind function with slope limiting for 1D advection problems. </p>
<p>This function implements an upwind scheme with slope limiting, using a higher-order approximation for the advection of the variable.</p><ul>
<li>If the velocity (V) is positive, the function computes a limited difference between Q2 and Q3, taking into account the values Q1, Q2, and Q3.</li>
<li>If the velocity (V) is negative, the function computes a limited difference between Q3 and Q4, considering Q2, Q3, and Q4.</li>
</ul>
<p>The function uses the MinMod limiter to avoid introducing non-physical oscillations. The limiter is scaled by a factor <code>thetaRC</code> which controls the amount of limiting applied. The value of <code>thetaRC</code> is defined in the <a class="el" href="GlobalVariables_8cpp.html" title="This file contains the global constants and variables used in the numerical solver for wave propagati...">GlobalVariables.cpp</a> file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>The velocity. </td></tr>
    <tr><td class="paramname">Q1</td><td>The value at the first neighboring point. </td></tr>
    <tr><td class="paramname">Q2</td><td>The value at the second neighboring point. </td></tr>
    <tr><td class="paramname">Q3</td><td>The value at the third neighboring point. </td></tr>
    <tr><td class="paramname">Q4</td><td>The value at the fourth neighboring point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The limited value at the interface. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_14807827589b339a04434892d1c1deae.html">src</a></li><li class="navelem"><a class="el" href="FluxComputation_8cpp.html">FluxComputation.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
