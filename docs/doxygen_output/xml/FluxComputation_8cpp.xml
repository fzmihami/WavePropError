<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.13.2" xml:lang="en-US">
  <compounddef id="FluxComputation_8cpp" kind="file" language="C++">
    <compoundname>FluxComputation.cpp</compoundname>
    <includes local="no">cstring</includes>
    <includes local="no">iostream</includes>
    <includes local="no">math.h</includes>
    <includes local="no">omp.h</includes>
    <includes refid="FluxComputation_8h" local="yes">FluxComputation.h</includes>
    <includes refid="GlobalVariables_8h" local="yes">GlobalVariables.h</includes>
    <incdepgraph>
      <node id="6">
        <label>FluxComputation.h</label>
        <link refid="FluxComputation_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>GlobalVariables.h</label>
        <link refid="GlobalVariables_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>ReadUserInput.h</label>
        <link refid="ReadUserInput_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>TimeVariables.h</label>
        <link refid="TimeVariables_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>code/src/FluxComputation.cpp</label>
        <link refid="FluxComputation_8cpp"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>cstring</label>
      </node>
      <node id="10">
        <label>fstream</label>
      </node>
      <node id="11">
        <label>iomanip</label>
      </node>
      <node id="3">
        <label>iostream</label>
      </node>
      <node id="4">
        <label>math.h</label>
      </node>
      <node id="5">
        <label>omp.h</label>
      </node>
      <node id="12">
        <label>string</label>
      </node>
      <node id="13">
        <label>vector</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="FluxComputation_8cpp_1ab5374d849e36ba16e42428a4674e16f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float upwind</definition>
        <argsstring>(float V, float Q1, float Q2)</argsstring>
        <name>upwind</name>
        <param>
          <type>float</type>
          <declname>V</declname>
        </param>
        <param>
          <type>float</type>
          <declname>Q1</declname>
        </param>
        <param>
          <type>float</type>
          <declname>Q2</declname>
        </param>
        <briefdescription>
<para>Upwind function for 1D advection problems. </para>
        </briefdescription>
        <detaileddescription>
<para>This function implements the basic upwind scheme. It returns one of the two input values, depending on the sign of the velocity.<itemizedlist>
<listitem><para>If the velocity (V) is positive, the function returns Q1.</para>
</listitem><listitem><para>If the velocity (V) is negative, the function returns Q2.</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>V</parametername>
</parameternamelist>
<parameterdescription>
<para>The velocity. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q1</parametername>
</parameternamelist>
<parameterdescription>
<para>The value at the left of the interface. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q2</parametername>
</parameternamelist>
<parameterdescription>
<para>The value at the right of the interface. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value corresponding to the upwind direction based on the velocity. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="97" column="7" bodyfile="code/src/FluxComputation.cpp" bodystart="97" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a03e356ed6b569840b09933d9538d1634" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float upwind</definition>
        <argsstring>(float V, float Q1, float Q2, float Q3, float Q4)</argsstring>
        <name>upwind</name>
        <param>
          <type>float</type>
          <declname>V</declname>
        </param>
        <param>
          <type>float</type>
          <declname>Q1</declname>
        </param>
        <param>
          <type>float</type>
          <declname>Q2</declname>
        </param>
        <param>
          <type>float</type>
          <declname>Q3</declname>
        </param>
        <param>
          <type>float</type>
          <declname>Q4</declname>
        </param>
        <briefdescription>
<para>Upwind function with slope limiting for 1D advection problems. </para>
        </briefdescription>
        <detaileddescription>
<para>This function implements an upwind scheme with slope limiting, using a higher-order approximation for the advection of the variable.<itemizedlist>
<listitem><para>If the velocity (V) is positive, the function computes a limited difference between Q2 and Q3, taking into account the values Q1, Q2, and Q3.</para>
</listitem><listitem><para>If the velocity (V) is negative, the function computes a limited difference between Q3 and Q4, considering Q2, Q3, and Q4.</para>
</listitem></itemizedlist>
</para>
<para>The function uses the MinMod limiter to avoid introducing non-physical oscillations. The limiter is scaled by a factor <computeroutput>thetaRC</computeroutput> which controls the amount of limiting applied. The value of <computeroutput>thetaRC</computeroutput> is defined in the <ref refid="GlobalVariables_8cpp" kindref="compound">GlobalVariables.cpp</ref> file.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>V</parametername>
</parameternamelist>
<parameterdescription>
<para>The velocity. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q1</parametername>
</parameternamelist>
<parameterdescription>
<para>The value at the first neighboring point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q2</parametername>
</parameternamelist>
<parameterdescription>
<para>The value at the second neighboring point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q3</parametername>
</parameternamelist>
<parameterdescription>
<para>The value at the third neighboring point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q4</parametername>
</parameternamelist>
<parameterdescription>
<para>The value at the fourth neighboring point. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The limited value at the interface. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="104" column="7" bodyfile="code/src/FluxComputation.cpp" bodystart="104" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float min3</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>min3</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="208" column="7" bodyfile="code/src/FluxComputation.cpp" bodystart="208" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a9cb524ba719998ee7ffe777b35beda4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float max3</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>max3</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="210" column="7" bodyfile="code/src/FluxComputation.cpp" bodystart="210" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a14240127a8376ac6eff63eaca802f766" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float minmod</definition>
        <argsstring>(float a, float b, float c)</argsstring>
        <name>minmod</name>
        <param>
          <type>float</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Computes the MinMod limiter function. </para>
        </briefdescription>
        <detaileddescription>
<para>The MinMod function is a slope limiter used in high-resolution schemes to prevent spurious oscillations. It selects the smallest absolute value among the inputs if they have the same sign; otherwise, it returns zero.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>First input value. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input value. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Third input value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The MinMod limited value.</para>
</simplesect>
The function follows these rules:<itemizedlist>
<listitem><para>If all three inputs are positive, it returns the minimum of the three.</para>
</listitem><listitem><para>If all three inputs are negative, it returns the maximum (most negative) of the three.</para>
</listitem><listitem><para>Otherwise, it returns zero to avoid introducing new extrema.</para>
</listitem></itemizedlist>
</para>
<para>Reference: Kim and Kim (2005) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="212" column="7" bodyfile="code/src/FluxComputation.cpp" bodystart="212" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a047d256037d27435f4f1218b38685b9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Recontruction_Order1</definition>
        <argsstring>(float *Hn, float *Hl, float *Hr, unsigned int N)</argsstring>
        <name>Recontruction_Order1</name>
        <param>
          <type>float *</type>
          <declname>Hn</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Performs first-order reconstruction of state variables at cell interfaces. </para>
        </briefdescription>
        <detaileddescription>
<para>This function approximates the state variables at the interface between computational cells using a first-order upwind reconstruction. It assigns values from the left and right neighboring cells, which can be used as inputs for a local Riemann solver in numerical flux computations.</para>
<para>The reconstruction follows:   <formula id="0">\[U_L^{i+1/2} = U_i
\]</formula>   <formula id="1">\[U_R^{i+1/2} = U_{i+1}
\]</formula> where <formula id="2">$ U_L $</formula> and <formula id="3">$ U_R $</formula> are the left and right states at the interface.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">Hn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array of state variables at cell centers (size N). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing left interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing right interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid points in the input array Hn.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>Ensure that <computeroutput>Hl</computeroutput> and <computeroutput>Hr</computeroutput> arrays have been allocated with at least <computeroutput>N-1</computeroutput> elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="222" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="222" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a0b1b58ffc138adc95d6b8573e56daf77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Recontruction_Order2</definition>
        <argsstring>(float *Hn, float *Hl, float *Hr, unsigned int N)</argsstring>
        <name>Recontruction_Order2</name>
        <param>
          <type>float *</type>
          <declname>Hn</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Performs second-order MUSCL reconstruction of state variables at cell interfaces. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the left and right interface states using the Monotonic Upstream-Centered Scheme for Conservation Laws (MUSCL), which provides a second-order accurate reconstruction with a Total Variation Diminishing (TVD) slope limiter.</para>
<para>The reconstructed interface values are given by:   <formula id="4">\[U_L^{i+1/2} = U_i + \phi (r_L) (U_i - U_{i-1})
\]</formula>   <formula id="5">\[U_R^{i+1/2} = U_{i+1} - \phi (r_R) (U_{i+2} - U_{i+1})
\]</formula></para>
<para>where the slope ratio is defined as:    <formula id="6">\[r_L = \frac{U_{i+1} - U_i}{U_i - U_{i-1}}, \quad
r_R = \frac{U_{i+1} - U_i}{U_{i+2} - U_{i+1}}
\]</formula></para>
<para>The function uses a Total Variation Diminishing (TVD) slope limiter to prevent oscillations. We use the Van-Leer MinMod limiter, defined as:   <formula id="7">\[\phi (r, \theta) = \max \left(0, \min \left( \theta r, \frac{1 + r}{2},
\theta \right) \right) \]</formula></para>
<para>the value of <formula id="8">$\theta$</formula> is defined as a constant in <ref refid="GlobalVariables_8cpp" kindref="compound">GlobalVariables.cpp</ref> file.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">Hn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array of state variables at cell centers (size N). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing left interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing right interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid points in the input array Hn.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>Ensure <computeroutput>Hl</computeroutput> and <computeroutput>Hr</computeroutput> arrays have at least <computeroutput>N-1</computeroutput> elements to avoid out-of-bounds errors. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="230" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="230" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a885eac6dccfcc8b73fdb27b433efa00b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Recontruction_Order3</definition>
        <argsstring>(float *Hn, float *Hl, float *Hr, unsigned int N)</argsstring>
        <name>Recontruction_Order3</name>
        <param>
          <type>float *</type>
          <declname>Hn</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Performs third-order TVD reconstruction of state variables at cell interfaces. </para>
        </briefdescription>
        <detaileddescription>
<para>This function implements the third-order Total Variation Diminishing (TVD) interpolation proposed by Kim and Kim (2005) for numerical flux computation. It ensures stability and prevents spurious oscillations using a nonlinear slope limiter.</para>
<para>The reconstructed interface values are given by:   <formula id="9">\[U_L^{i+1/2} = U_i + \max \left(0, \min \left(2, 2r_{L,i}, \beta_L \right)
\right) (U_i - U_{i-1}) \]</formula>  <formula id="10">\[ U_R^{i+1/2} = U_{i+1} - \max \left(0, \min
\left(2, 2r_{R,i+1}, \beta_R \right) \right) (U_{i+2} - U_{i+1}) \]</formula></para>
<para>where:    <formula id="11">\[\beta_L = \frac{1 + 2r_{L,i}}{3}, \quad
\beta_R = \frac{1 + 2r_{R,i+1}}{3}
\]</formula></para>
<para>and the slope ratios are:    <formula id="12">\[r_{L,i} = \frac{U_{i+1} - U_i}{U_i - U_{i-1}}, \quad
r_{R,i+1} = \frac{U_{i+1} - U_i}{U_{i+2} - U_{i+1}}
\]</formula></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">Hn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array of state variables at cell centers (size N). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing left interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing right interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid points in the input array Hn.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Assumes proper boundary handling for the first and last two grid points.</para>
</simplesect>
<simplesect kind="warning"><para>Ensure <computeroutput>Hl</computeroutput> and <computeroutput>Hr</computeroutput> arrays have at least <computeroutput>N-1</computeroutput> elements to avoid out-of-bounds errors. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="249" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="249" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1ae61ccf497bda712978ba2fac7e211d13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Recontruction_Order5</definition>
        <argsstring>(float *Hn, float *Hl, float *Hr, unsigned int N)</argsstring>
        <name>Recontruction_Order5</name>
        <param>
          <type>float *</type>
          <declname>Hn</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Performs fifth-order TVD reconstruction of state variables at cell interfaces. </para>
        </briefdescription>
        <detaileddescription>
<para>This function implements a fifth-order Total Variation Diminishing (TVD) interpolation for numerical flux computation. It uses a nonlinear slope limiter to prevent spurious oscillations while maintaining high accuracy.</para>
<para>The reconstructed interface values are given by:   <formula id="13">\[U_L^{i+1/2} = U_i + \frac{1}{2} \max \left(0, \min \left(2, 2r_{L,i}, \beta_L
\right) \right) (U_i - U_{i-1}) \]</formula>   <formula id="14">\[ U_R^{i+1/2} = U_{i+1} - \frac{1}{2}
\max \left(0, \min \left(2, 2r_{R,i+1}, \beta_R \right) \right) (U_{i+2} -
U_{i+1}) \]</formula></para>
<para>where the slope limiter coefficients are:    <formula id="15">\[\beta_L = \frac{-2/r_{L,i-1} + 11 + 24r_{L,i} - 3r_{L,i}r_{L,i+1}}{30},
\quad \beta_R = \frac{-2/r_{R,i+2} + 11 + 24r_{R,i+1} -
3r_{R,i}r_{R,i+1}}{30} \]</formula></para>
<para>The slope ratios are computed as:    <formula id="16">\[r_{L,i} = \frac{U_{i+1} - U_i}{U_i - U_{i-1}},
\quad r_{R,i+1} = \frac{U_{i} - U_{i-1}}{U_{i+1} - U_i}
\]</formula></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">Hn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array of state variables at cell centers (size N). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing left interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the array storing right interface values (size N-1). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid points in the input array Hn.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Assumes proper boundary handling for the first and last two grid points.</para>
</simplesect>
<simplesect kind="warning"><para>Ensure <computeroutput>Hl</computeroutput> and <computeroutput>Hr</computeroutput> arrays have at least <computeroutput>N-1</computeroutput> elements to avoid out-of-bounds errors.</para>
</simplesect>
Refrence: Kim and Kim (2005) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="290" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="290" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1ade1f7f95f720e6c73d063f64fe10f87e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Flux_CentralUpwind</definition>
        <argsstring>(float *Hl, float *Hr, float *Ql, float *Qr, float *FluxH, float *FluxQ, unsigned int N)</argsstring>
        <name>Flux_CentralUpwind</name>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Ql</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Qr</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>FluxH</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>FluxQ</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>Central-upwind scheme for numerical flux computation. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the numerical fluxes for the variables <computeroutput>h</computeroutput> (height) and <computeroutput>Q</computeroutput> (momentum) using the central-upwind scheme, as described by Kurganov and Petrova (2007).</para>
<para>The fluxes are calculated for each cell interface based on the left and right states, <computeroutput>Hl</computeroutput>, <computeroutput>Hr</computeroutput>, <computeroutput>Ql</computeroutput>, and <computeroutput>Qr</computeroutput>, and the speed of sound, <computeroutput>aL</computeroutput> and <computeroutput>aR</computeroutput>. The fluxes are computed for both <computeroutput>h</computeroutput> and <computeroutput>Q</computeroutput> using a central-upwind formula with local speeds <computeroutput>aL</computeroutput> and <computeroutput>aR</computeroutput>, and the fluxes are stored in <computeroutput>FluxH</computeroutput> and <computeroutput>FluxQ</computeroutput> respectively.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left state values for the height (h). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right state values for the height (h). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Ql</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left state values for the momentum (Q). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Qr</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right state values for the momentum (Q). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FluxH</parametername>
</parameternamelist>
<parameterdescription>
<para>The array where the numerical flux for height (h) will be stored. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FluxQ</parametername>
</parameternamelist>
<parameterdescription>
<para>The array where the numerical flux for momentum (Q) will be stored. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of cells.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The central-upwind numerical flux for each cell interface is computed as:</para>
<para><formula id="17">\[  F_{h}^{i+1/2} = \frac{a_R F_{hL} - a_L F_{hR}}{a_R - a_L} + \frac{a_R a_L
(H_r^{i} - H_l^{i})}{a_R - a_L}
\]</formula></para>
<para><formula id="18">\[  F_{Q}^{i+1/2} = \frac{a_R F_{uL} - a_L F_{uR}}{a_R - a_L} + \frac{a_R a_L
(Q_r^{i} - Q_l^{i})}{a_R - a_L}
\]</formula></para>
<para>where:</para>
<para><formula id="19">\[  a_R = \max\left(0, u_R + \sqrt{G H_R}, u_L + \sqrt{G H_L}\right)
\]</formula></para>
<para><formula id="20">\[  a_L = \min\left(0, u_R - \sqrt{G H_R}, u_L - \sqrt{G H_L}\right)
\]</formula></para>
<para>Reference: Kurganov, A., &amp; Petrova, G. (2007). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="336" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="336" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a1c4a609a92dc39c7441057fcf4a70e2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Flux_HLL</definition>
        <argsstring>(float *Hl, float *Hr, float *Ql, float *Qr, float *FluxH, float *FluxQ, unsigned int N)</argsstring>
        <name>Flux_HLL</name>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Ql</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Qr</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>FluxH</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>FluxQ</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>HLL (Harten, Lax, and van Leer) scheme for numerical flux computation. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the numerical fluxes for the variables <computeroutput>h</computeroutput> (height) and <computeroutput>Q</computeroutput> (momentum) using the HLL scheme (Harten, Lax, and van Leer, 1983).</para>
<para>The function calculates the fluxes for each cell interface based on the left and right states and local wave speeds, with the fluxes stored in the arrays <computeroutput>FluxH</computeroutput> and <computeroutput>FluxQ</computeroutput>. The fluxes are computed using the HLL algorithm.</para>
<para>The fluxes for height (<computeroutput>h</computeroutput>) and momentum (<computeroutput>Q</computeroutput>) are calculated using the following expressions:</para>
<para><formula id="21">\[\begin{aligned}
F_{h}^{i+1/2} =
\begin{cases}
F_{hL}, &amp; \text{if } s_L &gt; 0 \\
F_{hR}, &amp; \text{if } s_R &lt; 0 \\
\frac{s_R F_{hL} - s_L F_{hR} + (s_L s_R) (H_R - H_L)}{s_R - s_L}, &amp;
\text{otherwise} \end{cases} 
\end{aligned}
\]</formula></para>
<para><formula id="22">\[F_{Q}^{i+1/2} =
\begin{cases}
F_{Q_L}, &amp; \text{if } s_L &gt; 0 \\
F_{Q_R}, &amp; \text{if } s_R &lt; 0 \\
\frac{s_R F_{Q_L} - s_L F_{Q_R} + (s_L s_R) (Q_R - Q_L)}{s_R - s_L}, &amp;
\text{otherwise} \end{cases} \]</formula></para>
<para>where:<itemizedlist>
<listitem><para><formula id="23">$ s_L $</formula> is the left wave speed,</para>
</listitem><listitem><para><formula id="24">$ s_R $</formula> is the right wave speed,</para>
</listitem><listitem><para><formula id="25">$ F_{hL}, F_{hR} $</formula> are the fluxes for height,</para>
</listitem><listitem><para><formula id="26">$ F_{Q_L}, F_{Q_R} $</formula> are the fluxes for momentum.</para>
</listitem></itemizedlist>
</para>
<para>The wave speeds <formula id="23">$ s_L $</formula> and <formula id="24">$ s_R $</formula> are computed based on the local states and the characteristic speed of the system. The value <formula id="27">$ h0 $</formula> is computed based on the formulation in Toro (2009).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left state values for the height (h). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right state values for the height (h). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Ql</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left state values for the momentum (Q). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Qr</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right state values for the momentum (Q). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FluxH</parametername>
</parameternamelist>
<parameterdescription>
<para>The array where the numerical flux for height (h) will be stored. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FluxQ</parametername>
</parameternamelist>
<parameterdescription>
<para>The array where the numerical flux for momentum (Q) will be stored. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of cells.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Reference: Harten, A., Lax, P. D., &amp; van Leer, B. (1983). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="371" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="371" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="FluxComputation_8cpp_1a06eca82ea44bc6e1f759e96835038d81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Flux_HLLC</definition>
        <argsstring>(float *Hl, float *Hr, float *Ql, float *Qr, float *FluxH, float *FluxQ, unsigned int N)</argsstring>
        <name>Flux_HLLC</name>
        <param>
          <type>float *</type>
          <declname>Hl</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Hr</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Ql</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>Qr</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>FluxH</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>FluxQ</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>HLLC (Harten, Lax, van Leer, and Contact) scheme for numerical flux computation. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the numerical fluxes for the variables <computeroutput>h</computeroutput> (height) and <computeroutput>Q</computeroutput> (momentum) using the HLLC scheme (Harten, Lax, van Leer, and Contact, 1983). The HLLC scheme is a modification of the HLL scheme, which incorporates a contact wave and resolves the Riemann problem by considering three waves: a left and right moving wave, and a contact wave.</para>
<para>The function computes the fluxes for each cell interface based on the left and right states (<computeroutput>Hl</computeroutput>, <computeroutput>Hr</computeroutput>, <computeroutput>Ql</computeroutput>, <computeroutput>Qr</computeroutput>) and the corresponding wave speeds.</para>
<para>The fluxes for height (<computeroutput>h</computeroutput>) and momentum (<computeroutput>Q</computeroutput>) are calculated using the following expressions:</para>
<para><formula id="28">\[\begin{aligned}
F_{h}^{i+1/2} =
\begin{cases}
F_{hL}, &amp; \text{if } s_L &gt; 0 \\
F_{hR}, &amp; \text{if } s_R &lt; 0 \\
F_{hL} + s_L (h^*L - h_L), &amp; \text{if } 0 \leq s_0 \\
F_{hR} + s_R (h^*R - h_R), &amp; \text{if } s_0 &lt; 0
\end{cases}
\end{aligned}
\]</formula></para>
<para><formula id="29">\[F_{Q}^{i+1/2} =
\begin{cases}
F_{Q_L}, &amp; \text{if } s_L &gt; 0 \\
F_{Q_R}, &amp; \text{if } s_R &lt; 0 \\
F_{Q_L} + s_L (q^*L - h_L u_L), &amp; \text{if } 0 \leq s_0 \\
F_{Q_R} + s_R (q^*R - h_R u_R), &amp; \text{if } s_0 &lt; 0
\end{cases}
\]</formula></para>
<para>where:<itemizedlist>
<listitem><para><formula id="23">$ s_L $</formula> is the left wave speed,</para>
</listitem><listitem><para><formula id="24">$ s_R $</formula> is the right wave speed,</para>
</listitem><listitem><para><formula id="30">$ s_0 $</formula> is the middle wave speed (contact wave),</para>
</listitem><listitem><para><formula id="25">$ F_{hL}, F_{hR} $</formula> are the fluxes for height,</para>
</listitem><listitem><para><formula id="26">$ F_{Q_L}, F_{Q_R} $</formula> are the fluxes for momentum,</para>
</listitem><listitem><para><formula id="31">$ h^*L, h^*R $</formula> are the star variables for height at the left and right states,</para>
</listitem><listitem><para><formula id="32">$ q^*L, q^*R $</formula> are the star variables for momentum at the left and right states.</para>
</listitem></itemizedlist>
</para>
<para>The function uses intermediate variables, including <formula id="33">$ h_0 $</formula> (the averaged height), <formula id="34">$ u_0 $</formula> (the averaged velocity), and calculates the middle wave speed <formula id="30">$ s_0 $</formula> based on the expressions presented in Toro (2001).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hl</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left state values for the height (h). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Hr</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right state values for the height (h). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Ql</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left state values for the momentum (Q). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Qr</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right state values for the momentum (Q). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FluxH</parametername>
</parameternamelist>
<parameterdescription>
<para>The array where the numerical flux for height (h) will be stored. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FluxQ</parametername>
</parameternamelist>
<parameterdescription>
<para>The array where the numerical flux for momentum (Q) will be stored. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of cells.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Reference: Toro, 2001. &quot;Shock-capturing methods for free-surface shallow flows.&quot; </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="code/src/FluxComputation.cpp" line="431" column="6" bodyfile="code/src/FluxComputation.cpp" bodystart="431" bodyend="511"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Implementation of flux computation classes for the Shallow Water Equations on both collocated and staggered grids. </para>
    </briefdescription>
    <detaileddescription>
<para>This file defines the <computeroutput>flux</computeroutput> and <computeroutput><ref refid="classflux__staggered" kindref="compound">flux_staggered</ref></computeroutput> classes used to compute fluxes in the Shallow Water Equations. The <computeroutput>flux</computeroutput> class supports collocated grids using the Finite Volume Godunov method, while the <computeroutput><ref refid="classflux__staggered" kindref="compound">flux_staggered</ref></computeroutput> class is designed for staggered grids, implementing a conservative staggered scheme based on Stelling and Duinmeijer (2003). </para>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstring&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;math.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;omp.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="FluxComputation_8h" kindref="compound">FluxComputation.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="GlobalVariables_8h" kindref="compound">GlobalVariables.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Flux<sp/>staggered<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="comment">//<sp/>///////////////////////////////////////////////////////////////////////////</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"><ref refid="classflux__staggered_1a50d7bab30663331b7203a3b49f4e9c25" kindref="member">flux_staggered::flux_staggered</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/>this-&gt;N<sp/>=<sp/>N;</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><ref refid="classflux__staggered_1a4b056356ee504a8b01be6b746378f81d" kindref="member">WS</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N];</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux__staggered_1a4b056356ee504a8b01be6b746378f81d" kindref="member">WS</ref>,<sp/>0,<sp/>N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>+<sp/>1];</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>,<sp/>0,<sp/>(N<sp/>+<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><ref refid="classflux__staggered_1a2e6fe0d852341d0324e2f5b3e2ab2f30" kindref="member">HUUn</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N];</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux__staggered_1a2e6fe0d852341d0324e2f5b3e2ab2f30" kindref="member">HUUn</ref>,<sp/>0,<sp/>N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="31"><highlight class="normal">}</highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"><ref refid="classflux__staggered_1af346837e589bbbebce50b3f07a204465" kindref="member">flux_staggered::~flux_staggered</ref>()<sp/>{</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux__staggered_1a4b056356ee504a8b01be6b746378f81d" kindref="member">WS</ref>;</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>;</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux__staggered_1a2e6fe0d852341d0324e2f5b3e2ab2f30" kindref="member">HUUn</ref>;</highlight></codeline>
<codeline lineno="37"><highlight class="normal">}</highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classflux__staggered_1ac5c4e71e1d64faca3f970ffebe8c8ebe" kindref="member">flux_staggered::ComputeFlux</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classState" kindref="compound">State</ref><sp/>&amp;S0,</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;OrderReconstruction)<sp/>{</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(OrderReconstruction<sp/>!=<sp/>1<sp/>&amp;&amp;<sp/>OrderReconstruction<sp/>!=<sp/>2)<sp/>{</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>Order<sp/>of<sp/>reconstruction<sp/>not<sp/>implemented<sp/>for<sp/>the<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;conservative<sp/>staggered<sp/>scheme&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Compute<sp/>flux<sp/>continuity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>(N<sp/>+<sp/>1);<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i]<sp/>=<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i]<sp/>*<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i];</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>==<sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i]<sp/>=<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i]<sp/>*<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(OrderReconstruction<sp/>==<sp/>1<sp/>||<sp/>i<sp/>==<sp/>1<sp/>||<sp/>i<sp/>==<sp/>N<sp/>-<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i]<sp/>=<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i]<sp/>*<sp/><ref refid="FluxComputation_8h_1ab5374d849e36ba16e42428a4674e16f3" kindref="member">upwind</ref>(S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i],<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i<sp/>-<sp/>1],<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i]);</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i]<sp/>=<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i]<sp/>*<sp/><ref refid="FluxComputation_8h_1ab5374d849e36ba16e42428a4674e16f3" kindref="member">upwind</ref>(S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i],<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i<sp/>-<sp/>2],<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i<sp/>-<sp/>1],<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i],</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i<sp/>+<sp/>1]);</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Compute<sp/>flux<sp/>momentum</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="71"><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>pr<sp/>=<sp/>0.5<sp/>*<sp/>(<ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i]<sp/>+<sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i<sp/>+<sp/>1]);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>ur;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>==<sp/>0<sp/>||<sp/>i<sp/>==<sp/>N<sp/>-<sp/>1<sp/>||<sp/>OrderReconstruction<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ur<sp/>=<sp/><ref refid="FluxComputation_8h_1ab5374d849e36ba16e42428a4674e16f3" kindref="member">upwind</ref>(pr,<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i],<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i<sp/>+<sp/>1]);</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ur<sp/>=<sp/><ref refid="FluxComputation_8h_1ab5374d849e36ba16e42428a4674e16f3" kindref="member">upwind</ref>(pr,<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i<sp/>-<sp/>1],<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i],<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i<sp/>+<sp/>1],<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i<sp/>+<sp/>2]);</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1a2e6fe0d852341d0324e2f5b3e2ab2f30" kindref="member">HUUn</ref>[i]<sp/>=<sp/>pr<sp/>*<sp/>ur;</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight><highlight class="comment">//<sp/>compute<sp/>wave<sp/>speed<sp/>-<sp/>Stelling<sp/>and<sp/>Duinmeijer<sp/>(2003)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i]<sp/>&lt;<sp/><ref refid="GlobalVariables_8h_1a777989279445ddc055c317df60b3dd64" kindref="member">hmin</ref>)<sp/>{</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1a4b056356ee504a8b01be6b746378f81d" kindref="member">WS</ref>[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classflux__staggered_1a4b056356ee504a8b01be6b746378f81d" kindref="member">WS</ref>[i]<sp/>=<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i])<sp/>+<sp/>fabs(<ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i<sp/>+<sp/>1]<sp/>+<sp/><ref refid="classflux__staggered_1ad667361ac320bb15f1c574fca5c0f3cb" kindref="member">HUn</ref>[i])<sp/>/<sp/>(2<sp/>*<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i]);</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="95"><highlight class="normal">}</highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1ab5374d849e36ba16e42428a4674e16f3" kindref="member">upwind</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>V,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>Q1,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>Q2)<sp/>{</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(V<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Q1;</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Q2;</highlight></codeline>
<codeline lineno="102"><highlight class="normal">}</highlight></codeline>
<codeline lineno="103"><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1ab5374d849e36ba16e42428a4674e16f3" kindref="member">upwind</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>V,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>Q1,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>Q2,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>Q3,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>Q4)<sp/>{</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(V<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(Q2<sp/>+<sp/>0.5<sp/>*<sp/><ref refid="FluxComputation_8cpp_1a14240127a8376ac6eff63eaca802f766" kindref="member">minmod</ref>(<ref refid="GlobalVariables_8h_1a87f49feba762f3dd933bf0df4b960a2a" kindref="member">thetaRC</ref><sp/>*<sp/>(Q3<sp/>-<sp/>Q2),<sp/>0.5<sp/>*<sp/>(Q3<sp/>-<sp/>Q1),</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GlobalVariables_8h_1a87f49feba762f3dd933bf0df4b960a2a" kindref="member">thetaRC</ref><sp/>*<sp/>(Q2<sp/>-<sp/>Q1)));</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(Q3<sp/>-<sp/>0.5<sp/>*<sp/><ref refid="FluxComputation_8cpp_1a14240127a8376ac6eff63eaca802f766" kindref="member">minmod</ref>(<ref refid="GlobalVariables_8h_1a87f49feba762f3dd933bf0df4b960a2a" kindref="member">thetaRC</ref><sp/>*<sp/>(Q4<sp/>-<sp/>Q3),<sp/>0.5<sp/>*<sp/>(Q4<sp/>-<sp/>Q2),</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GlobalVariables_8h_1a87f49feba762f3dd933bf0df4b960a2a" kindref="member">thetaRC</ref><sp/>*<sp/>(Q3<sp/>-<sp/>Q2)));</highlight></codeline>
<codeline lineno="111"><highlight class="normal">}</highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>Flux<sp/>class<sp/>Collocated<sp/>grid</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>///////////////////////////////////////////////////////////////////////////</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><ref refid="classflux_1ad12f9ebd94d5fc3acc6bc9ab0546b947" kindref="member">flux::flux</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/>this-&gt;N<sp/>=<sp/>N;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><ref refid="classflux_1a0bed9e6ca693154d6db8c6574b50bb60" kindref="member">WS</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N];</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1a0bed9e6ca693154d6db8c6574b50bb60" kindref="member">WS</ref>,<sp/>0,<sp/>N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N];</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>,<sp/>0,<sp/>N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N];</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>,<sp/>0,<sp/>N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/>0,<sp/>(N<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/>0,<sp/>(N<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/>0,<sp/>(N<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/>0,<sp/>(N<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><ref refid="classflux_1adfdcb49efed897bd7006b9d1f20e3c71" kindref="member">FluxH</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1adfdcb49efed897bd7006b9d1f20e3c71" kindref="member">FluxH</ref>,<sp/>0,<sp/>(N<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><ref refid="classflux_1a6527f04e525e156d0753409d9769924e" kindref="member">FluxU</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/>memset(<ref refid="classflux_1a6527f04e525e156d0753409d9769924e" kindref="member">FluxU</ref>,<sp/>0,<sp/>(N<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="136"><highlight class="normal">}</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><ref refid="classflux_1ad6c3e1f342c841e8b0914e61bc833083" kindref="member">flux::~flux</ref>()<sp/>{</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1a0bed9e6ca693154d6db8c6574b50bb60" kindref="member">WS</ref>;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>;</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>;</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>;</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>;</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>;</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>;</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1adfdcb49efed897bd7006b9d1f20e3c71" kindref="member">FluxH</ref>;</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">[]<sp/><ref refid="classflux_1a6527f04e525e156d0753409d9769924e" kindref="member">FluxU</ref>;</highlight></codeline>
<codeline lineno="148"><highlight class="normal">}</highlight></codeline>
<codeline lineno="149"><highlight class="normal"></highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classflux_1a5bbf9064fed1080784110a2e9318ad36" kindref="member">flux::ComputeFlux</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classState" kindref="compound">State</ref><sp/>&amp;S0,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="GlobalVariables_8h_1a1a1ed40592bd51f9b25af65953320968" kindref="member">scheme</ref><sp/>&amp;Scheme,</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;OrderReconstruction)<sp/>{</highlight></codeline>
<codeline lineno="152"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Compute<sp/>Qn<sp/>=<sp/>Hn*Un</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>[i]<sp/>=<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i];</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>[i]<sp/>=<sp/>S0.<ref refid="classState_1a28f63f0cd7b0d7943e2cf5c9e1028ae1" kindref="member">Hn</ref>[i]<sp/>*<sp/>S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i];</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="158"><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Reconstruction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(OrderReconstruction)<sp/>{</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>1:</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a047d256037d27435f4f1218b38685b9b" kindref="member">Recontruction_Order1</ref>(<ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>,<sp/><ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a047d256037d27435f4f1218b38685b9b" kindref="member">Recontruction_Order1</ref>(<ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>2:</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a0b1b58ffc138adc95d6b8573e56daf77" kindref="member">Recontruction_Order2</ref>(<ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>,<sp/><ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a0b1b58ffc138adc95d6b8573e56daf77" kindref="member">Recontruction_Order2</ref>(<ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>3:</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a885eac6dccfcc8b73fdb27b433efa00b" kindref="member">Recontruction_Order3</ref>(<ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>,<sp/><ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a885eac6dccfcc8b73fdb27b433efa00b" kindref="member">Recontruction_Order3</ref>(<ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>5:</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1ae61ccf497bda712978ba2fac7e211d13" kindref="member">Recontruction_Order5</ref>(<ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>,<sp/><ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1ae61ccf497bda712978ba2fac7e211d13" kindref="member">Recontruction_Order5</ref>(<ref refid="classflux_1af3266be4d4330ef110a0cc8065df608c" kindref="member">Qn</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>Order<sp/>of<sp/>reconstruction<sp/>not<sp/>implemented&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Flux<sp/>computation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(Scheme)<sp/>{</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="GlobalVariables_8h_1a1a1ed40592bd51f9b25af65953320968a7395c1b2905d77784d2d0af187e482a6" kindref="member">scheme::central_upwind</ref>:</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1ade1f7f95f720e6c73d063f64fe10f87e" kindref="member">Flux_CentralUpwind</ref>(<ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/><ref refid="classflux_1adfdcb49efed897bd7006b9d1f20e3c71" kindref="member">FluxH</ref>,<sp/><ref refid="classflux_1a6527f04e525e156d0753409d9769924e" kindref="member">FluxU</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="GlobalVariables_8h_1a1a1ed40592bd51f9b25af65953320968a37ea226464a76d4f841772ff1f5843c0" kindref="member">scheme::hllc</ref>:</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a06eca82ea44bc6e1f759e96835038d81" kindref="member">Flux_HLLC</ref>(<ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/><ref refid="classflux_1adfdcb49efed897bd7006b9d1f20e3c71" kindref="member">FluxH</ref>,<sp/><ref refid="classflux_1a6527f04e525e156d0753409d9769924e" kindref="member">FluxU</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="GlobalVariables_8h_1a1a1ed40592bd51f9b25af65953320968af2e3f15077facd1d4f26626f532ec4e9" kindref="member">scheme::hll</ref>:</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="FluxComputation_8h_1a1c4a609a92dc39c7441057fcf4a70e2f" kindref="member">Flux_HLL</ref>(<ref refid="classflux_1af99086969bd3966c3fc28bcb8fc478b4" kindref="member">HL</ref>,<sp/><ref refid="classflux_1ac99fb062e3d35e84297c5f9163b80332" kindref="member">HR</ref>,<sp/><ref refid="classflux_1a39216f37660192a5ea9aa2cd2b16e28e" kindref="member">QL</ref>,<sp/><ref refid="classflux_1ad0098376f298fb5ba4ec7648feabfd46" kindref="member">QR</ref>,<sp/><ref refid="classflux_1adfdcb49efed897bd7006b9d1f20e3c71" kindref="member">FluxH</ref>,<sp/><ref refid="classflux_1a6527f04e525e156d0753409d9769924e" kindref="member">FluxU</ref>,<sp/>N);</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>Scheme<sp/>not<sp/>implemented&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight><highlight class="comment">//<sp/>compute<sp/>wave<sp/>speed</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classflux_1a0bed9e6ca693154d6db8c6574b50bb60" kindref="member">WS</ref>[i]<sp/>=<sp/>fabs(S0.<ref refid="classState_1aa769a173d9fe2757c1e5fc8fc2ca6ece" kindref="member">Un</ref>[i])<sp/>+<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/><ref refid="classflux_1a4ed77c0022f6c88683401962047eb0af" kindref="member">Hn</ref>[i]);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="203"><highlight class="normal">}</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>Reconstruction<sp/>functions<sp/>+<sp/>limiters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>//////////////////////////////////////////////////////////</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" kindref="member">min3</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>b,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>c)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::min(std::min(a,<sp/>b),<sp/>c);<sp/>}</highlight></codeline>
<codeline lineno="209"><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a9cb524ba719998ee7ffe777b35beda4d" kindref="member">max3</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>b,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>c)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::max(std::max(a,<sp/>b),<sp/>c);<sp/>}</highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a14240127a8376ac6eff63eaca802f766" kindref="member">minmod</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>b,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>c)<sp/>{</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(a<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>b<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>c<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::min(a,<sp/>std::min(b,<sp/>c));</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(a<sp/>&lt;<sp/>0<sp/>&amp;&amp;<sp/>b<sp/>&lt;<sp/>0<sp/>&amp;&amp;<sp/>c<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::max(a,<sp/>std::max(b,<sp/>c));</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="220"><highlight class="normal">}</highlight></codeline>
<codeline lineno="221"><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a047d256037d27435f4f1218b38685b9b" kindref="member">Recontruction_Order1</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hn,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/>Hl[i]<sp/>=<sp/>Hn[i];</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/>Hr[i]<sp/>=<sp/>Hn[i<sp/>+<sp/>1];</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="228"><highlight class="normal">}</highlight></codeline>
<codeline lineno="229"><highlight class="normal"></highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a0b1b58ffc138adc95d6b8573e56daf77" kindref="member">Recontruction_Order2</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hn,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hx<sp/>=<sp/>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)malloc(N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/>memset(Hx,<sp/>0,<sp/>N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/>Hx[i]<sp/>=<sp/><ref refid="FluxComputation_8cpp_1a14240127a8376ac6eff63eaca802f766" kindref="member">minmod</ref>(<ref refid="GlobalVariables_8h_1a87f49feba762f3dd933bf0df4b960a2a" kindref="member">thetaRC</ref><sp/>*<sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]),<sp/>0.5<sp/>*<sp/>(Hn[i<sp/>+<sp/>1]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]),</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GlobalVariables_8h_1a87f49feba762f3dd933bf0df4b960a2a" kindref="member">thetaRC</ref><sp/>*<sp/>(Hn[i<sp/>+<sp/>1]<sp/>-<sp/>Hn[i]));</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>Hl[i]<sp/>=<sp/>Hn[i]<sp/>+<sp/>0.5<sp/>*<sp/>Hx[i];</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/>Hr[i]<sp/>=<sp/>Hn[i<sp/>+<sp/>1]<sp/>-<sp/>0.5<sp/>*<sp/>Hx[i<sp/>+<sp/>1];</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="245"><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/>free(Hx);</highlight></codeline>
<codeline lineno="247"><highlight class="normal">}</highlight></codeline>
<codeline lineno="248"><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a885eac6dccfcc8b73fdb27b433efa00b" kindref="member">Recontruction_Order3</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hn,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*rL<sp/>=<sp/>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)malloc(N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*rR<sp/>=<sp/>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)malloc(N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>bL,<sp/>bR;</highlight></codeline>
<codeline lineno="254"><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/>rL[i]<sp/>=<sp/>(Hn[i<sp/>+<sp/>1]<sp/>-<sp/>Hn[i]<sp/>+<sp/>1E-20)<sp/>/<sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]<sp/>+<sp/>1E-20);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/>rR[i]<sp/>=<sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]<sp/>+<sp/>1E-20)<sp/>/<sp/>(Hn[i<sp/>+<sp/>1]<sp/>-<sp/>Hn[i]<sp/>+<sp/>1E-20);</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/>rL[0];</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/>rL[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/>rR[0];</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/>rR[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>2;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>3;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/>bL<sp/>=<sp/>(1.0<sp/>+<sp/>2<sp/>*<sp/>rL[i])<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/>bR<sp/>=<sp/>(1.0<sp/>+<sp/>2<sp/>*<sp/>rR[i<sp/>+<sp/>1])<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="270"><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/>Hl[i]<sp/>=<sp/>Hn[i]<sp/>+<sp/>0.5<sp/>*<sp/>std::max(0.0f,<sp/><ref refid="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" kindref="member">min3</ref>(2.0f,<sp/>2<sp/>*<sp/>rL[i],<sp/>bL))<sp/>*</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]);</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/>Hr[i]<sp/>=<sp/>Hn[i<sp/>+<sp/>1]<sp/>-<sp/>0.5<sp/>*<sp/>std::max(0.0f,<sp/><ref refid="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" kindref="member">min3</ref>(2.0f,<sp/>2<sp/>*<sp/>rR[i<sp/>+<sp/>1],<sp/>bR))<sp/>*</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Hn[i<sp/>+<sp/>2]<sp/>-<sp/>Hn[i<sp/>+<sp/>1]);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/>Hl[0]<sp/>=<sp/>Hn[0];</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/>Hr[0]<sp/>=<sp/>Hn[1];</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/>Hl[1]<sp/>=<sp/>Hn[1];</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/>Hr[1]<sp/>=<sp/>Hn[2];</highlight></codeline>
<codeline lineno="280"><highlight class="normal"></highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/>Hl[N<sp/>-<sp/>2]<sp/>=<sp/>Hn[N<sp/>-<sp/>2];</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/>Hr[N<sp/>-<sp/>2]<sp/>=<sp/>Hn[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/>Hl[N<sp/>-<sp/>3]<sp/>=<sp/>Hn[N<sp/>-<sp/>3];</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/>Hr[N<sp/>-<sp/>3]<sp/>=<sp/>Hn[N<sp/>-<sp/>2];</highlight></codeline>
<codeline lineno="285"><highlight class="normal"></highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/>free(rL);</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/>free(rR);</highlight></codeline>
<codeline lineno="288"><highlight class="normal">}</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1ae61ccf497bda712978ba2fac7e211d13" kindref="member">Recontruction_Order5</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hn,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*rL<sp/>=<sp/>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)malloc(N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*rR<sp/>=<sp/>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)malloc(N<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="293"><highlight class="normal"></highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>bL,<sp/>bR;</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/>rL[i]<sp/>=<sp/>(Hn[i<sp/>+<sp/>1]<sp/>-<sp/>Hn[i]<sp/>+<sp/>1E-20)<sp/>/<sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]<sp/>+<sp/>1E-20);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/>rR[i]<sp/>=<sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]<sp/>+<sp/>1E-20)<sp/>/<sp/>(Hn[i<sp/>+<sp/>1]<sp/>-<sp/>Hn[i]<sp/>+<sp/>1E-20);</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/>rL[0];</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/>rL[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/>rR[0];</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/>rR[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="305"><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>2;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>3;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="308"><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/>bL<sp/>=<sp/>(-2.0<sp/>/<sp/>rL[i<sp/>-<sp/>1]<sp/>+<sp/>11.0<sp/>+<sp/>24.0<sp/>*<sp/>rL[i]<sp/>-<sp/>3.0<sp/>*<sp/>rL[i]<sp/>*<sp/>rL[i<sp/>+<sp/>1])<sp/>/</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>30.0;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/>bR<sp/>=</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(-2.0<sp/>/<sp/>rR[i<sp/>+<sp/>2]<sp/>+<sp/>11.0<sp/>+<sp/>24.0<sp/>*<sp/>rR[i<sp/>+<sp/>1]<sp/>-<sp/>3.0<sp/>*<sp/>rR[i]<sp/>*<sp/>rR[i<sp/>+<sp/>1])<sp/>/</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>30.0;</highlight></codeline>
<codeline lineno="314"><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/>Hl[i]<sp/>=<sp/>Hn[i]<sp/>+<sp/>0.5<sp/>*<sp/>std::max(0.0f,<sp/><ref refid="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" kindref="member">min3</ref>(2.0,<sp/>2<sp/>*<sp/>rL[i],<sp/>bL))<sp/>*</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Hn[i]<sp/>-<sp/>Hn[i<sp/>-<sp/>1]);</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>Hr[i]<sp/>=<sp/>Hn[i<sp/>+<sp/>1]<sp/>-<sp/>0.5<sp/>*<sp/>std::max(0.0f,<sp/><ref refid="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" kindref="member">min3</ref>(2.0,<sp/>2<sp/>*<sp/>rR[i<sp/>+<sp/>1],<sp/>bR))<sp/>*</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Hn[i<sp/>+<sp/>2]<sp/>-<sp/>Hn[i<sp/>+<sp/>1]);</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/>Hl[0]<sp/>=<sp/>Hn[0];</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/>Hr[0]<sp/>=<sp/>Hn[1];</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/>Hl[1]<sp/>=<sp/>Hn[1];</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/>Hr[1]<sp/>=<sp/>Hn[2];</highlight></codeline>
<codeline lineno="324"><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/>Hl[N<sp/>-<sp/>2]<sp/>=<sp/>Hn[N<sp/>-<sp/>2];</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/>Hr[N<sp/>-<sp/>2]<sp/>=<sp/>Hn[N<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/>Hl[N<sp/>-<sp/>3]<sp/>=<sp/>Hn[N<sp/>-<sp/>3];</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/>Hr[N<sp/>-<sp/>3]<sp/>=<sp/>Hn[N<sp/>-<sp/>2];</highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/>free(rL);</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/>free(rR);</highlight></codeline>
<codeline lineno="332"><highlight class="normal">}</highlight></codeline>
<codeline lineno="333"><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Flux<sp/>compuation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal"></highlight><highlight class="comment">//<sp/>///////////////////////////////////////////////////////////////////////////////</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="336"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1ade1f7f95f720e6c73d063f64fe10f87e" kindref="member">Flux_CentralUpwind</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Ql,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Qr,</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*FluxH,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*FluxQ,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>hL,<sp/>hR,<sp/>uL,<sp/>uR;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>FhL,<sp/>FhR,<sp/>FuL,<sp/>FuR;</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>aL,<sp/>aR;</highlight></codeline>
<codeline lineno="341"><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/>hL<sp/>=<sp/>Hl[i];</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/>uL<sp/>=<sp/>Ql[i]<sp/>/<sp/>hL;</highlight></codeline>
<codeline lineno="347"><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/>FhL<sp/>=<sp/>Ql[i];</highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/>FuL<sp/>=<sp/>Ql[i]<sp/>*<sp/>uL<sp/>+<sp/>0.5<sp/>*<sp/><ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>Hl[i]<sp/>*<sp/>Hl[i];</highlight></codeline>
<codeline lineno="350"><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Right<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="352"><highlight class="normal"></highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/>hR<sp/>=<sp/>Hr[i];</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/>uR<sp/>=<sp/>Qr[i]<sp/>/<sp/>hR;</highlight></codeline>
<codeline lineno="355"><highlight class="normal"></highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/>FhR<sp/>=<sp/>Qr[i];</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/>FuR<sp/>=<sp/>Qr[i]<sp/>*<sp/>uR<sp/>+<sp/>0.5<sp/>*<sp/><ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>Hr[i]<sp/>*<sp/>Hr[i];</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Local<sp/>Speeds</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/>aL<sp/>=<sp/><ref refid="FluxComputation_8cpp_1a1427a5bc052b35ab5a40fa74efa38688" kindref="member">min3</ref>(0,<sp/>uR<sp/>-<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR),<sp/>uL<sp/>-<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL));</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>aR<sp/>=<sp/><ref refid="FluxComputation_8cpp_1a9cb524ba719998ee7ffe777b35beda4d" kindref="member">max3</ref>(0,<sp/>uR<sp/>+<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR),<sp/>uL<sp/>+<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL));</highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Central<sp/>Upwind<sp/>Algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>(aR<sp/>*<sp/>FhL<sp/>-<sp/>aL<sp/>*<sp/>FhR)<sp/>/<sp/>(aR<sp/>-<sp/>aL)<sp/>+</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(aR<sp/>*<sp/>aL<sp/>*<sp/>(Hr[i]<sp/>-<sp/>Hl[i]))<sp/>/<sp/>(aR<sp/>-<sp/>aL);</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>(aR<sp/>*<sp/>FuL<sp/>-<sp/>aL<sp/>*<sp/>FuR)<sp/>/<sp/>(aR<sp/>-<sp/>aL)<sp/>+</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(aR<sp/>*<sp/>aL<sp/>*<sp/>(Qr[i]<sp/>-<sp/>Ql[i]))<sp/>/<sp/>(aR<sp/>-<sp/>aL);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="369"><highlight class="normal">}</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a1c4a609a92dc39c7441057fcf4a70e2f" kindref="member">Flux_HLL</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Ql,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Qr,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*FluxH,</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*FluxQ,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>hL,<sp/>hR,<sp/>uL,<sp/>uR;</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>FhL,<sp/>FhR,<sp/>FuL,<sp/>FuR;</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>qL,<sp/>qR;</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>h0;</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>sL,<sp/>sR;</highlight></codeline>
<codeline lineno="378"><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="381"><highlight class="normal"></highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Left<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/>hL<sp/>=<sp/>Hl[i];</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/>uL<sp/>=<sp/>Ql[i]<sp/>/<sp/>Hl[i];</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/>FhL<sp/>=<sp/>hL<sp/>*<sp/>uL;</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/>FuL<sp/>=<sp/>hL<sp/>*<sp/>uL<sp/>*<sp/>uL<sp/>+<sp/><ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL<sp/>*<sp/>hL<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Right<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/>hR<sp/>=<sp/>Hr[i];</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/>uR<sp/>=<sp/>Qr[i]<sp/>/<sp/>Hr[i];</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/>FhR<sp/>=<sp/>hR<sp/>*<sp/>uR;</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/>FuR<sp/>=<sp/>hR<sp/>*<sp/>uR<sp/>*<sp/>uR<sp/>+<sp/><ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR<sp/>*<sp/>hR<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="393"><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>h*</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>h0<sp/>=<sp/>0.5<sp/>*<sp/>(hL<sp/>+<sp/>hR)<sp/>-</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.25<sp/>*<sp/>(uR<sp/>-<sp/>uL)<sp/>*<sp/>(hL<sp/>+<sp/>hR)<sp/>/<sp/>(sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL)<sp/>+<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR));</highlight></codeline>
<codeline lineno="397"><highlight class="normal"></highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>QL,<sp/>QR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h0<sp/>&gt;<sp/>hL)<sp/>{</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qL<sp/>=<sp/>sqrt(0.5<sp/>*<sp/>(h0<sp/>+<sp/>hL)<sp/>*<sp/>h0<sp/>/<sp/>(hL<sp/>*<sp/>hL));</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qL<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h0<sp/>&gt;<sp/>hR)<sp/>{</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qR<sp/>=<sp/>sqrt(0.5<sp/>*<sp/>(h0<sp/>+<sp/>hR)<sp/>*<sp/>h0<sp/>/<sp/>(hR<sp/>*<sp/>hR));</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qR<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="410"><highlight class="normal"></highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Left<sp/>and<sp/>right<sp/>speeds</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/>sL<sp/>=<sp/>uL<sp/>-<sp/>qL<sp/>*<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL);</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/>sR<sp/>=<sp/>uR<sp/>+<sp/>qR<sp/>*<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR);</highlight></codeline>
<codeline lineno="414"><highlight class="normal"></highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>HLL<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(0<sp/>&lt;<sp/>sL)<sp/>{</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>FhL;</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>FuL;</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sR<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>FhR;</highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>FuR;</highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(sR<sp/>*<sp/>FhL<sp/>-<sp/>sL<sp/>*<sp/>FhR<sp/>+<sp/>(sL<sp/>*<sp/>sR)<sp/>*<sp/>(Hr[i]<sp/>-<sp/>Hl[i]))<sp/>/<sp/>(sR<sp/>-<sp/>sL);</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(sR<sp/>*<sp/>FuL<sp/>-<sp/>sL<sp/>*<sp/>FuR<sp/>+<sp/>(sL<sp/>*<sp/>sR)<sp/>*<sp/>(Qr[i]<sp/>-<sp/>Ql[i]))<sp/>/<sp/>(sR<sp/>-<sp/>sL);</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="429"><highlight class="normal">}</highlight></codeline>
<codeline lineno="430"><highlight class="normal"></highlight></codeline>
<codeline lineno="431"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="FluxComputation_8cpp_1a06eca82ea44bc6e1f759e96835038d81" kindref="member">Flux_HLLC</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hl,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Hr,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Ql,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*Qr,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*FluxH,</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*FluxQ,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>hL,<sp/>hR,<sp/>uL,<sp/>uR;</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>FhL,<sp/>FhR,<sp/>FuL,<sp/>FuR;</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>qL,<sp/>qR;</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>h0,<sp/>u0;</highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>sL,<sp/>sR,<sp/>s0;<sp/></highlight><highlight class="comment">//<sp/>s0<sp/>is<sp/>the<sp/>middle<sp/>wave<sp/>speed</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>hStarL,<sp/>hStarR,<sp/>qStarL,<sp/>qStarR;</highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>kL,<sp/>kR;</highlight></codeline>
<codeline lineno="442"><highlight class="normal"></highlight></codeline>
<codeline lineno="443"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>omp<sp/>parallel<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>N<sp/>-<sp/>1;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Left<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/>hL<sp/>=<sp/>Hl[i];</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/>uL<sp/>=<sp/>Ql[i]<sp/>/<sp/>Hl[i];</highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/>FhL<sp/>=<sp/>hL<sp/>*<sp/>uL;</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/>FuL<sp/>=<sp/>hL<sp/>*<sp/>uL<sp/>*<sp/>uL<sp/>+<sp/><ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL<sp/>*<sp/>hL<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="450"><highlight class="normal"></highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Right<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>hR<sp/>=<sp/>Hr[i];</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>uR<sp/>=<sp/>Qr[i]<sp/>/<sp/>Hr[i];</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/>FhR<sp/>=<sp/>hR<sp/>*<sp/>uR;</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/>FuR<sp/>=<sp/>hR<sp/>*<sp/>uR<sp/>*<sp/>uR<sp/>+<sp/><ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR<sp/>*<sp/>hR<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="456"><highlight class="normal"></highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>h*</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/>h0<sp/>=<sp/>0.5<sp/>*<sp/>(hL<sp/>+<sp/>hR)<sp/>-</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.25<sp/>*<sp/>(uR<sp/>-<sp/>uL)<sp/>*<sp/>(hL<sp/>+<sp/>hR)<sp/>/<sp/>(sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL)<sp/>+<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR));</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>u0<sp/>=</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.5<sp/>*<sp/>(uL<sp/>+<sp/>uR)<sp/>-<sp/>(hR<sp/>-<sp/>hL)<sp/>*<sp/>(sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL)<sp/>+<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR))<sp/>/<sp/>(hL<sp/>+<sp/>hR);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"></highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>QL,<sp/>QR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h0<sp/>&gt;<sp/>hL)<sp/>{</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qL<sp/>=<sp/>sqrt(0.5<sp/>*<sp/>(h0<sp/>+<sp/>hL)<sp/>*<sp/>h0<sp/>/<sp/>(hL<sp/>*<sp/>hL));</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qL<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="469"><highlight class="normal"></highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h0<sp/>&gt;<sp/>hR)<sp/>{</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qR<sp/>=<sp/>sqrt(0.5<sp/>*<sp/>(h0<sp/>+<sp/>hR)<sp/>*<sp/>h0<sp/>/<sp/>(hR<sp/>*<sp/>hR));</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>qR<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="475"><highlight class="normal"></highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Left<sp/>and<sp/>right<sp/>speeds</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/>sL<sp/>=<sp/>uL<sp/>-<sp/>qL<sp/>*<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hL);</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/>sR<sp/>=<sp/>uR<sp/>+<sp/>qR<sp/>*<sp/>sqrt(<ref refid="GlobalVariables_8h_1accf9cafc36aeda21688e19a1c2d3888d" kindref="member">G</ref><sp/>*<sp/>hR);</highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>middle<sp/>wave<sp/>speed<sp/>s0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/>s0<sp/>=<sp/>(sL<sp/>*<sp/>hR<sp/>*<sp/>(uR<sp/>-<sp/>sR)<sp/>-<sp/>sR<sp/>*<sp/>hL<sp/>*<sp/>(uL<sp/>-<sp/>sL))<sp/>/</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(hR<sp/>*<sp/>(uR<sp/>-<sp/>sR)<sp/>-<sp/>hL<sp/>*<sp/>(uL<sp/>-<sp/>sL));</highlight></codeline>
<codeline lineno="483"><highlight class="normal"></highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>U*<sp/>L/R</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>coefficients<sp/>U*<sp/>=<sp/>K<sp/>*<sp/>[1,<sp/>s0]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/>kL<sp/>=<sp/>hL<sp/>*<sp/>(sL<sp/>-<sp/>uL)<sp/>/<sp/>(sL<sp/>-<sp/>s0);</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/>kR<sp/>=<sp/>hR<sp/>*<sp/>(sR<sp/>-<sp/>uR)<sp/>/<sp/>(sR<sp/>-<sp/>s0);</highlight></codeline>
<codeline lineno="488"><highlight class="normal"></highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/>hStarL<sp/>=<sp/>kL;</highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/>hStarR<sp/>=<sp/>kR;</highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/>qStarL<sp/>=<sp/>kL<sp/>*<sp/>s0;</highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/>qStarR<sp/>=<sp/>kR<sp/>*<sp/>s0;</highlight></codeline>
<codeline lineno="493"><highlight class="normal"></highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>HLLC<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(0<sp/>&lt;=<sp/>sL)<sp/>{</highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>FhL;</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>FuL;</highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sR<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>FhR;</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>FuR;</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(0<sp/>&lt;=<sp/>s0)<sp/>{</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>FhL<sp/>+<sp/>sL<sp/>*<sp/>(hStarL<sp/>-<sp/>hL);</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>FuL<sp/>+<sp/>sL<sp/>*<sp/>(qStarL<sp/>-<sp/>hL<sp/>*<sp/>uL);</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FluxH[i]<sp/>=<sp/>FhR<sp/>+<sp/>sR<sp/>*<sp/>(hStarR<sp/>-<sp/>hR);</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FluxQ[i]<sp/>=<sp/>FuR<sp/>+<sp/>sR<sp/>*<sp/>(qStarR<sp/>-<sp/>hR<sp/>*<sp/>uR);</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="511"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="code/src/FluxComputation.cpp"/>
  </compounddef>
</doxygen>
